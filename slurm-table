#!/usr/bin/env python3
import json
import re
import shutil
import subprocess
import sys
from collections import defaultdict

SLOT_WIDTH = 8
CPU_MODE = "allocated"


def usage():
    prog = sys.argv[0] if sys.argv and sys.argv[0] else "slurm-table"
    print(
        "Usage: {} [--slot-width N] [--cpu-mode percentage|allocated]".format(prog),
        file=sys.stderr,
    )


def parse_args(argv):
    global SLOT_WIDTH, CPU_MODE

    i = 0
    while i < len(argv):
        arg = argv[i]

        if arg in ("-h", "--help"):
            usage()
            sys.exit(0)
        elif arg == "--slot-width":
            i += 1
            if i >= len(argv):
                print("Error: --slot-width requires a value", file=sys.stderr)
                usage()
                sys.exit(2)
            try:
                SLOT_WIDTH = int(argv[i])
            except ValueError:
                print("Error: --slot-width must be an integer", file=sys.stderr)
                sys.exit(2)
            if SLOT_WIDTH < 3:
                print("Error: --slot-width must be >= 3", file=sys.stderr)
                sys.exit(2)
        elif arg.startswith("--slot-width="):
            try:
                SLOT_WIDTH = int(arg.split("=", 1)[1])
            except ValueError:
                print("Error: --slot-width must be an integer", file=sys.stderr)
                sys.exit(2)
            if SLOT_WIDTH < 3:
                print("Error: --slot-width must be >= 3", file=sys.stderr)
                sys.exit(2)
        elif arg == "--cpu-mode":
            i += 1
            if i >= len(argv):
                print("Error: --cpu-mode requires a value", file=sys.stderr)
                usage()
                sys.exit(2)
            CPU_MODE = argv[i]
        elif arg.startswith("--cpu-mode="):
            CPU_MODE = arg.split("=", 1)[1]
        else:
            print("Error: unknown argument: {}".format(arg), file=sys.stderr)
            usage()
            sys.exit(2)

        i += 1

    if CPU_MODE not in ("percentage", "allocated"):
        print(
            "Error: --cpu-mode must be one of: percentage, allocated", file=sys.stderr
        )
        sys.exit(2)


def format_cpu_field(info):
    if CPU_MODE == "allocated":
        total = info.get("cpu_total")
        alloc = info.get("cpu_alloc")
        if total is None or alloc is None or total <= 0:
            return "?/?"
        return "{}/{}".format(alloc, total)
    return info["cpuload"]


def run_cmd(cmd):
    # doesn't work in < py37
    # return subprocess.check_output(cmd, text=True, stderr=subprocess.DEVNULL)
    proc = subprocess.Popen(
        cmd,
        stdout=subprocess.PIPE,
        stderr=subprocess.DEVNULL,
        universal_newlines=True,
    )
    out, _ = proc.communicate()
    if proc.returncode:
        raise subprocess.CalledProcessError(proc.returncode, cmd, output=out)
    if out is None:
        return ""
    if isinstance(out, bytes):
        try:
            out = out.decode("utf-8", "replace")
        except Exception:
            out = out.decode(errors="replace")

    return out


def try_cmd(cmd):
    try:
        return run_cmd(cmd)
    except Exception:
        return None


def natural_node_key(name):
    m = re.match(r"^(.*?)(\d+)$", name)
    if m:
        return (m.group(1), int(m.group(2)))
    return (name, -1)


def expand_nodelist(expr):
    expr = expr.strip()
    if not expr:
        return []
    if "[" not in expr:
        return [expr]

    m = re.match(r"^(.*?)\[(.*?)\](.*)$", expr)
    if not m:
        return [expr]

    prefix, body, suffix = m.groups()
    out = []
    for part in body.split(","):
        part = part.strip()
        if "-" in part:
            a, b = part.split("-", 1)
            width = max(len(a), len(b))
            for i in range(int(a), int(b) + 1):
                out.append(f"{prefix}{i:0{width}d}{suffix}")
        else:
            out.append(f"{prefix}{part}{suffix}")
    return out


def parse_gpu_count_from_text(*values):
    nums = []
    for value in values:
        if not value:
            continue
        s = str(value)
        nums.extend(re.findall(r"(?:gres/)?gpu[:=](\d+)", s))
        nums.extend(re.findall(r"gpu:[^:|, ]+:(\d+)", s))
    if nums:
        return max(int(x) for x in nums)
    return 1


def format_cpuload(value):
    if value is None:
        return "?"
    if isinstance(value, str):
        s = value.strip()
        if not s:
            return "?"
        try:
            f = float(s)
        except ValueError:
            return s
    else:
        try:
            f = float(value)
        except Exception:
            return str(value)

    # Some JSON outputs report hundredths (e.g. 3966 instead of 39.66).
    if f >= 1000:
        f = f / 100.0
    return f"{f:.2f}"


def make_job_block(jobid, span):
    label = str(jobid)
    inner_width = SLOT_WIDTH * span + (span - 1) - 2

    if inner_width <= 0:
        return "<>"
    if inner_width <= len(label):
        return "<" + label[:inner_width] + ">"
    if span == 1:
        return f"<{label:^{inner_width}}>"

    pad = inner_width - len(label)
    left = pad // 2
    right = pad - left
    return "<" + ("~" * left) + label + ("~" * right) + ">"


def parse_top_squeue(text):
    return text.rstrip("\n")


def parse_running_squeue_text(text):
    jobs_by_node = defaultdict(list)

    for raw in text.splitlines():
        line = raw.rstrip()
        if not line:
            continue

        parts = re.split(r"\s+", line.strip(), maxsplit=3)
        if len(parts) < 3:
            continue

        jobid = parts[0]
        nodelist = parts[1]
        tail = " ".join(parts[2:])
        gpu_count = max(1, parse_gpu_count_from_text(tail))

        for node in expand_nodelist(nodelist):
            jobs_by_node[node].append(
                {
                    "jobid": int(jobid),
                    "gpus": gpu_count,
                }
            )

    return jobs_by_node


def parse_running_squeue_json(text):
    data = json.loads(text)
    jobs_by_node = defaultdict(list)

    for job in data.get("jobs", []):
        job_id = job.get("job_id")
        if job_id is None:
            continue

        try:
            jobid = int(job_id)
        except Exception:
            continue

        nodes = expand_nodelist(str(job.get("nodes", "")))
        if not nodes:
            continue

        gpu_count = 1
        for key in ("tres", "tres_per_node", "tres_alloc_str", "tres_req_str"):
            if key in job and job[key] is not None:
                blob = (
                    job[key]
                    if isinstance(job[key], str)
                    else json.dumps(job[key], separators=(",", ":"))
                )
                gpu_count = max(gpu_count, parse_gpu_count_from_text(blob))

        for node in nodes:
            jobs_by_node[node].append(
                {
                    "jobid": jobid,
                    "gpus": gpu_count,
                }
            )

    return jobs_by_node


def parse_nodes_sinfo(text):
    nodes = {}
    for raw in text.splitlines():
        line = raw.strip()
        if not line:
            continue
        parts = line.split("|", 4)
        if len(parts) < 5:
            continue
        name, cpuload, state, gres, cpu_summary = [p.strip() for p in parts]
        if not name:
            continue

        total_gpus = max(1, parse_gpu_count_from_text(gres))
        state = state.upper().split("+", 1)[0]
        cpuload = format_cpuload(cpuload)
        cpu_alloc = None
        cpu_total = None

        cpu_parts = cpu_summary.split("/")
        if len(cpu_parts) == 4:
            try:
                cpu_alloc = int(cpu_parts[0])
                cpu_total = int(cpu_parts[3])
            except Exception:
                cpu_alloc = None
                cpu_total = None

        prev = nodes.get(name)
        if prev is None:
            nodes[name] = {
                "cpuload": cpuload,
                "state": state,
                "total_gpus": total_gpus,
                "cpu_alloc": cpu_alloc,
                "cpu_total": cpu_total,
            }
        else:
            if prev["cpuload"] == "?" and cpuload != "?":
                prev["cpuload"] = cpuload
            if prev["state"] in ("UNKNOWN", "") and state not in ("UNKNOWN", ""):
                prev["state"] = state
            prev["total_gpus"] = max(prev["total_gpus"], total_gpus)
            if prev.get("cpu_alloc") is None and cpu_alloc is not None:
                prev["cpu_alloc"] = cpu_alloc
            if prev.get("cpu_total") is None and cpu_total is not None:
                prev["cpu_total"] = cpu_total
    return nodes


def parse_nodes_text(text):
    nodes = {}

    for raw in text.splitlines():
        line = raw.strip()
        if not line:
            continue

        fields = dict(re.findall(r"(\w+)=([^\s]+)", line))
        name = fields.get("NodeName")
        if not name:
            continue

        cpuload = format_cpuload(fields.get("CPULoad", "?"))
        state = fields.get("State", "UNKNOWN").split("+", 1)[0].upper()
        cfg_tres = fields.get("CfgTRES", "")
        gres = fields.get("Gres", "")
        cpu_alloc = fields.get("CPUAlloc")
        cpu_total = fields.get("CPUTot")

        total_gpus = max(
            parse_gpu_count_from_text(cfg_tres), parse_gpu_count_from_text(gres)
        )
        if total_gpus < 1:
            total_gpus = 8

        nodes[name] = {
            "cpuload": cpuload,
            "state": state,
            "total_gpus": total_gpus,
            "cpu_alloc": int(cpu_alloc) if cpu_alloc and cpu_alloc.isdigit() else None,
            "cpu_total": int(cpu_total) if cpu_total and cpu_total.isdigit() else None,
        }

    return nodes


def parse_nodes_json(text):
    data = json.loads(text)
    nodes = {}

    for node in data.get("nodes", []):
        name = node.get("name")
        if not name:
            continue

        state_field = node.get("state")
        if isinstance(state_field, list) and state_field:
            state = str(state_field[0]).upper()
        elif isinstance(state_field, str):
            state = state_field.split("+", 1)[0].upper()
        else:
            state = "UNKNOWN"

        total_gpus = 0
        for key in ("tres", "tres_fmt_str", "config_tres", "gres"):
            if key in node and node[key] is not None:
                blob = (
                    node[key]
                    if isinstance(node[key], str)
                    else json.dumps(node[key], separators=(",", ":"))
                )
                total_gpus = max(total_gpus, parse_gpu_count_from_text(blob))
        cpu_alloc = None
        cpu_total = None

        for key in ("cpu_alloc", "alloc_cpus", "allocated_cpus"):
            if key in node and node[key] is not None:
                try:
                    cpu_alloc = int(node[key])
                    break
                except Exception:
                    pass
        for key in ("cpus", "cpu_tot", "effective_cpus"):
            if key in node and node[key] is not None:
                try:
                    cpu_total = int(node[key])
                    break
                except Exception:
                    pass

        nodes[name] = {
            "cpuload": format_cpuload(node.get("cpu_load", "?")),
            "state": state,
            "total_gpus": max(1, total_gpus or 8),
            "cpu_alloc": cpu_alloc,
            "cpu_total": cpu_total,
        }

    return nodes


def get_top_table():
    text = try_cmd(["squeue"])
    if not text:
        return ""
    return parse_top_squeue(text)


def get_running_jobs():
    text = try_cmd(["squeue", "--json", "-a", "-h", "-t", "R"])
    if text:
        try:
            return parse_running_squeue_json(text)
        except Exception:
            pass

    text = run_cmd(
        [
            "squeue",
            "-a",
            "-h",
            "-t",
            "R",
            "-O",
            "JobID:20,NodeList:40,tres-alloc:40,tres-per-node:40",
        ]
    )
    return parse_running_squeue_text(text)


def get_nodes():
    nodes = {}

    # use sinfo here because it can expose all partitions/nodes and directly gives CPU load (%O).
    text = try_cmd(["sinfo", "-a", "-N", "-h", "-o", "%N|%O|%T|%G|%C"])
    if text:
        try:
            nodes.update(parse_nodes_sinfo(text))
        except Exception:
            pass

    text = try_cmd(["scontrol", "--json", "show", "node"])
    if text:
        try:
            for name, info in parse_nodes_json(text).items():
                nodes.setdefault(name, info)
                nodes[name]["cpuload"] = (
                    info["cpuload"]
                    if nodes[name].get("cpuload", "?") == "?"
                    else nodes[name]["cpuload"]
                )
                if nodes[name].get("state", "UNKNOWN") == "UNKNOWN":
                    nodes[name]["state"] = info["state"]
                if (
                    nodes[name].get("cpu_alloc") is None
                    and info.get("cpu_alloc") is not None
                ):
                    nodes[name]["cpu_alloc"] = info["cpu_alloc"]
                if (
                    nodes[name].get("cpu_total") is None
                    and info.get("cpu_total") is not None
                ):
                    nodes[name]["cpu_total"] = info["cpu_total"]
                nodes[name]["total_gpus"] = max(
                    nodes[name].get("total_gpus", 1), info["total_gpus"]
                )
        except Exception:
            pass

    if not nodes:
        text = run_cmd(["scontrol", "show", "node", "-o"])
        nodes.update(parse_nodes_text(text))

    return nodes


def render_bottom_table(nodes, jobs_by_node):
    if not nodes:
        return ""

    max_slots = max(info["total_gpus"] for info in nodes.values())
    node_w = (
        max(8, max(len(n) for n in nodes)) + 1
    )  # match the left margin in the sample
    cpu_label = "%CPU" if CPU_MODE == "percentage" else "CPU A/F"
    cpu_w = max(
        len(cpu_label), max(len(format_cpu_field(info)) for info in nodes.values())
    )
    state_w = max(5, max(len(info["state"]) for info in nodes.values()))

    header = " " * node_w + "|"
    for i in range(1, max_slots + 1):
        header += f" {'#' + str(i):^{SLOT_WIDTH - 2}} |"
    header += f" {cpu_label:>{cpu_w}} | {'State':<{state_w}}"

    sep = "-" * node_w + "|"
    for i in range(1, max_slots + 1):
        sep += "-" * SLOT_WIDTH
        sep += "+" if i != max_slots else "|"
    sep += "-" * (cpu_w + 2) + "|" + "-" * (state_w + 2)

    lines = [header, sep]

    for node in sorted(nodes, key=natural_node_key):
        info = nodes[node]
        total_slots = info["total_gpus"]
        jobs = sorted(jobs_by_node.get(node, []), key=lambda j: j["jobid"])

        row = f"{node:>{node_w}}|"
        used = 0

        for job in jobs:
            span = max(1, int(job["gpus"]))
            if used >= total_slots:
                break
            if used + span > total_slots:
                span = total_slots - used
            row += make_job_block(job["jobid"], span) + "|"
            used += span

        while used < total_slots:
            row += (" " * SLOT_WIDTH) + "|"
            used += 1

        row += f" {format_cpu_field(info):>{cpu_w}} | {info['state']:<{state_w}}"
        lines.append(row)

    return "\n".join(lines)


def main():
    parse_args(sys.argv[1:])
    for cmd in ("squeue", "scontrol", "sinfo"):
        if not shutil.which(cmd):
            print(f"Error: {cmd} not found in PATH", file=sys.stderr)
            sys.exit(1)

    # top = get_top_table()
    jobs_by_node = get_running_jobs()
    nodes = get_nodes()

    for node, jobs in jobs_by_node.items():
        if node not in nodes:
            inferred = sum(max(1, int(j.get("gpus", 1))) for j in jobs)
            nodes[node] = {
                "cpuload": "?",
                "state": "UNKNOWN",
                "total_gpus": max(8, inferred),
                "cpu_alloc": None,
                "cpu_total": None,
            }
    # if top:
    #     print(top)
    #     print()
    #     print("---")
    #     print()
    print(render_bottom_table(nodes, jobs_by_node))


if __name__ == "__main__":
    try:
        main()
    except subprocess.CalledProcessError as e:
        print(f"Error running: {' '.join(e.cmd)}", file=sys.stderr)
        sys.exit(e.returncode if e.returncode else 1)
